# 星历选择逻辑优化记录

## 问题描述

在卫星预报星历文件（RINEX导航电文）中，存在**多条星历的参考时间（TOE）相同**的情况。通常这种情况下，其中一条星历会存在数据异常，直接使用会导致计算出错误的卫星坐标。

## 原始逻辑

```cpp
// 遍历所有星历，找到时间最接近的
for(auto& ephem : sat.Ephemerys){
    double time_diff = fabs(ephem.TOE - t);
    if(time_diff < min_time_diff){
        min_time_diff = time_diff;
        best_ephem = &ephem;
    }
}
```

**问题**：仅根据TOE与观测时间t的差值选择星历，当多条星历TOE相同时，只会选择第一条遇到的，无法区分数据质量。

## 优化方案（老师建议）

**当多条星历的TOE相同时，选择 `toc`（卫星钟参考时间）与 `toe` 最接近的那条星历**，因为通常toc与toe接近的星历数据更为可靠。

## 实现细节

### 1. 添加toc转GPS周内秒函数

在 `Ephemery` 类中添加辅助函数，将toc时间转换为GPS周内秒（与TOE同单位），便于比较：

```cpp
// 将toc转换为GPS周内秒（从周日0时开始的秒数）
double toc_to_gps_seconds() const {
    int y = toc.year;
    int m = toc.month;
    int d = toc.day;
    
    // 蔡勒公式计算星期几 (0=周日, 1-6=周一到周六)
    if (m < 3) {
        m += 12;
        y -= 1;
    }
    int k = y % 100;
    int j = y / 100;
    int dow = (d + (13 * (m + 1)) / 5 + k + k / 4 + j / 4 - 2 * j) % 7;
    dow = ((dow + 6) % 7);  // 转换为0=周日
    
    // 计算周内秒
    double seconds_in_day = toc.hour * 3600.0 + toc.minute * 60.0 + toc.second;
    return dow * 86400.0 + seconds_in_day;
}
```

### 2. 修改星历选择逻辑

```cpp
// 为每个时间点选择最接近的星历
for(double t = 0; t <= 86400; t += 300.0){
    Ephemery* best_ephem = nullptr;
    double min_time_diff = TMP_MAX;
    double min_toc_toe_diff = TMP_MAX;  // toc与toe的最小差值
    
    for(auto& ephem : sat.Ephemerys){
        double time_diff = fabs(ephem.TOE - t);
        
        // 计算toc与toe的差值（用于判断数据质量）
        double toc_seconds = ephem.toc_to_gps_seconds();
        double toc_toe_diff = fabs(toc_seconds - ephem.TOE);
        // 处理跨周的情况
        if(toc_toe_diff > 302400) toc_toe_diff = 604800 - toc_toe_diff;
        
        if(time_diff < min_time_diff){
            // 找到更接近的星历
            min_time_diff = time_diff;
            min_toc_toe_diff = toc_toe_diff;
            best_ephem = &ephem;
        } else if(time_diff == min_time_diff && toc_toe_diff < min_toc_toe_diff){
            // toe与t的差值相同，但toc与toe更接近，选择这个星历
            min_toc_toe_diff = toc_toe_diff;
            best_ephem = &ephem;
        }
    }
    // ... 后续计算卫星位置
}
```

## 改进效果

| 项目 | 修改前 | 修改后 |
|------|--------|--------|
| TOE重复时的选择策略 | 选择第一条遇到的 | 选择toc与toe最接近的 |
| 数据异常星历的处理 | 无法避免 | 可通过toc-toe差值筛选 |
| 跨GPS周边界处理 | 无 | 已考虑（差值>302400秒时取补） |

## 原理说明

- **TOE (Time of Ephemeris)**：星历参考时间，轨道参数的参考时刻
- **TOC (Time of Clock)**：钟差参数的参考时刻

正常情况下，TOC与TOE应该相等或非常接近。如果某条星历的TOC与TOE差距较大，说明该星历可能存在数据问题，不应优先使用。

---

# GEO卫星坐标计算特殊处理

## 问题描述

根据北斗ICD文件，**BDS GEO卫星**（地球静止轨道卫星）的坐标计算方式与GPS及BDS MEO/IGSO卫星不同，需要额外的坐标变换。原代码中所有卫星都使用同一公式，未区分GEO卫星。

## 北斗卫星轨道类型

| 轨道类型 | PRN编号 | 说明 |
|---------|---------|------|
| **GEO** | C01-C05, C59-C63 | 地球静止轨道，需特殊处理 |
| **IGSO** | C06-C10, C13, C16, C38-C40 | 倾斜地球同步轨道 |
| **MEO** | C11-C12, C14, C19-C37, C41-C46 | 中圆地球轨道 |

## 坐标计算公式

### 情况A：GPS及BDS MEO/IGSO卫星

计算观测时刻升交点经度 $L$（已包含地球自转修正）：

$$L = \Omega_0 + (\dot{\Omega} - \omega_e)t_k - \omega_e t_{oe}$$

通过旋转矩阵转换坐标：

$$X = x_k' \cos L - y_k' \cos i_k \sin L$$
$$Y = x_k' \sin L + y_k' \cos i_k \cos L$$
$$Z = y_k' \sin i_k$$

### 情况B：BDS GEO卫星

**Step 1**：计算惯性系下的升交点经度：

$$\Omega_k = \Omega_0 + \dot{\Omega} t_k - \omega_e t_{oe}$$

**Step 2**：计算惯性系下的坐标：

$$X_{GK} = x_k' \cos \Omega_k - y_k' \cos i_k \sin \Omega_k$$
$$Y_{GK} = x_k' \sin \Omega_k + y_k' \cos i_k \cos \Omega_k$$
$$Z_{GK} = y_k' \sin i_k$$

**Step 3**：地球自转修正（绕Z轴旋转 $\phi = \omega_e t_k$）：

$$X' = X_{GK} \cos\phi + Y_{GK} \sin\phi$$
$$Y' = -X_{GK} \sin\phi + Y_{GK} \cos\phi$$
$$Z' = Z_{GK}$$

**Step 4**：绕X轴旋转 $-5°$（GEO卫星轨道倾角修正）：

$$X = X'$$
$$Y = Y' \cos(-5°) + Z' \sin(-5°)$$
$$Z = -Y' \sin(-5°) + Z' \cos(-5°)$$

## 代码实现

```cpp
// 判断是否为BDS GEO卫星 (C01-C05, C59-C63)
bool is_geo = false;
if(PRN[0] == 'C') {
    int prn_num = stoi(PRN.substr(1, 2));
    if((prn_num >= 1 && prn_num <= 5) || (prn_num >= 59 && prn_num <= 63)) {
        is_geo = true;
    }
}

if(is_geo) {
    // 情况B: BDS GEO卫星
    double Omega_k = Omega + Omega_dot * tk - omega_e * TOE;
    
    // 惯性系坐标
    double X_GK = x_orbit * cos(Omega_k) - y_orbit * cos(i) * sin(Omega_k);
    double Y_GK = x_orbit * sin(Omega_k) + y_orbit * cos(i) * cos(Omega_k);
    double Z_GK = y_orbit * sin(i);
    
    // 地球自转修正 + 绕X轴旋转-5度
    double phi = omega_e * tk;
    double angle_x = -5.0 * M_PI / 180.0;
    
    double X_temp = X_GK * cos(phi) + Y_GK * sin(phi);
    double Y_temp = -X_GK * sin(phi) + Y_GK * cos(phi);
    double Z_temp = Z_GK;
    
    X = X_temp;
    Y = Y_temp * cos(angle_x) + Z_temp * sin(angle_x);
    Z = -Y_temp * sin(angle_x) + Z_temp * cos(angle_x);
} else {
    // 情况A: GPS卫星及BDS MEO/IGSO卫星
    double L = Omega + (Omega_dot - omega_e) * tk - omega_e * TOE;
    X = x_orbit * cos(L) - y_orbit * cos(i) * sin(L);
    Y = x_orbit * sin(L) + y_orbit * cos(i) * cos(L);
    Z = y_orbit * sin(i);
}
```

## 补充说明

由于Windows平台下 `M_PI` 可能未定义，需在文件开头添加：

```cpp
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif
```

---

# 调试过程：发现星历异常问题

## 问题现象

在与SP3精密星历对比验证时，发现部分北斗卫星（如C36）在某些时刻的计算坐标与精密星历偏差异常大，而其他时刻及其他卫星的误差在正常范围内。

## 调试方法

### 1. 添加调试输出

在代码中针对异常卫星和时间点添加详细输出：

```cpp
if(sat.PRN == "C36" && t == 41400) {
    cout << "\n===========================\n";
    cout << " C36 调试信息 t = " << t << " 秒\n";
    cout << "===========================\n";

    if(best_ephem) {
        cout << "使用的星历 TOE = " << best_ephem->TOE
             << "   (与 t 的差 min_time_diff = " << min_time_diff << ")\n\n";

        cout << "星历参数：\n";
        cout << "  sqrt(A)     = " << best_ephem->sqrt_A << "\n";
        cout << "  e           = " << best_ephem->e << "\n";
        cout << "  i0          = " << best_ephem->i_0 << "\n";
        // ... 其他参数

        Point3D pos = best_ephem->calc_coordinate(t);
        cout << "\n计算后的坐标：\n";
        cout << "  X = " << pos.x << "\n";
        cout << "  Y = " << pos.y << "\n";
        cout << "  Z = " << pos.z << "\n";
    }
}
```

### 2. 发现问题

通过调试输出发现：

- 同一卫星在同一TOE时刻存在**多条星历记录**
- 其中一条星历的轨道参数（如 `sqrt_A`, `e` 等）存在异常值
- 原代码只按TOE与观测时间差选择星历，无法排除异常数据

### 3. 验证方法

对比同一TOE的多条星历，检查其 `toc`（钟差参考时间）与 `toe` 的差值：

- 正常星历：`toc` 与 `toe` 相同或非常接近
- 异常星历：`toc` 与 `toe` 差距较大

### 4. 解决方案

修改星历选择逻辑：当多条星历的TOE相同时，优先选择 `toc` 与 `toe` 差值最小的星历。

## 调试输出示例

```
===========================
 C36 调试信息 t = 41400 秒
===========================
使用的星历 TOE = 43200   (与 t 的差 min_time_diff = 1800)

星历参数：
  sqrt(A)     = 6493.65
  e           = 0.000822444
  i0          = 0.956077
  ...

计算后的坐标：
  X = -7.12575e+06
  Y = 1.44888e+07
  Z = 2.27885e+07
===========================
```

## 经验总结

1. **问题定位**：通过添加详细调试输出，逐步缩小问题范围
2. **多源验证**：将计算结果与精密星历对比，确认异常点
3. **根因分析**：发现广播星历文件中同一TOE可能存在多条记录
4. **解决思路**：利用 `toc` 与 `toe` 的一致性作为数据质量判断依据
